介绍：
堆其实就是优先级队列，两个是一个东西，想要知道什么是堆，就先要了解什么是完全二叉树，然后再了解什么是大根堆、什么是小根堆。
都了解了之后，就有一个公式可以知道当前节点的父节点、左右子节点的下标。
当前节点i的父节点 = i-1/2  左节点 = i*2+1  
右节点 = i*2 +2。

上升（heapInsert）O(logn)：
然后就开始想象加入用户向你一个个的添加数字，你要根据数字的大小维持大根堆的数据结构，我们就可以每次进来一个数字都与自己的父节点进行比较，如果比父节点大，就与父节点交换位置，反之不动，这个过程就是heapInsert过程。（此处要有heapInsert的代码示例，并分析时间复杂度）。

然后我们继续加功能。
下沉（heapify）O(logn)：
现在我们不添加数字了，而是找到大根堆中最大的数，并把它删掉。
我们知道最大的数肯定在0位置，那么我们就可以记录它的值，并删掉，重要的是怎么在删掉后保持大根堆的结构呢。
我们可以把0位置的数与最后位置的数进行交换，然后把heapSize从原本的大小减一，这样就实现了逻辑删除，然后我们就要调整结构，因为现在0位置的数并不是最大的，我们可以通过把它和它的左右子节点进行比较，有比它大的就进行交换，并且在比较的时候要注意如果左右子节点的下标超过了heapSize，就说明该元素不存在。（此处要有heapify的代码示例，并分析时间复杂度）。

那其实系统已经帮我们实现了堆的数据结构，也就是优先级队列，就是PriorityQueue，默认是小根堆。（此处要有PriorityQueue的使用示例）。

那么接下来，假如原本是好好的大根堆，但是突然中间一个数x变了，那么如何恢复到大根堆结构呢，只需要执行heapInsert(x)和heapify(x)这两个方法，如果x变大了可能执行heapInsert(x)，但绝对不可能执行heapify(x)，反之亦然，所有通过这两个方法就可以将其恢复到正确的大根堆结构。

堆排序：
接下来说堆排序(heapSort)
堆排序就是，假如给你一个无序的数组，你要把它变有序，你可以先把它转换成大根堆，就假设先把第一个数当作用户传给你的，你把它转换成大根堆，然后再把数组的第二个数当作传给你的第二个数，你把前两个数转换为大根堆，以此类推，把整个数组转换为大根堆。
然后呢我们把0位置的数(肯定是最大的)，移动到最后一个位置，然后heapSize--，这样最后的数就永远不动了，再处理剩下的数，以此类推，当heapSize等于0的时候就说明按照从小到大排好序了。（此处要有heapSort的代码示例，并分析时间复杂度）
数据量增加常数法
从上往下建堆时间复杂度是O(N*logn)
从下往上建堆时间复杂度是O(N)

最后还有一个题目就是给你一个无序数组，但是该数组并不是完全无序，而是每个数离它原本的位置不会超过k，此题就可以根据小根堆进行解题，就是将第一个元素包括它后面的k个数加入到小根堆中，然后弹出最小的数就一定是原本在该位置的数。